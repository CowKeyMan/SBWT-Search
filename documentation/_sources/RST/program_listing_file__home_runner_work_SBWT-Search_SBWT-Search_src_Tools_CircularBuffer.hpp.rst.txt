
.. _program_listing_file__home_runner_work_SBWT-Search_SBWT-Search_src_Tools_CircularBuffer.hpp:

Program Listing for File CircularBuffer.hpp
===========================================

|exhale_lsh| :ref:`Return to documentation for file <file__home_runner_work_SBWT-Search_SBWT-Search_src_Tools_CircularBuffer.hpp>` (``/home/runner/work/SBWT-Search/SBWT-Search/src/Tools/CircularBuffer.hpp``)

.. |exhale_lsh| unicode:: U+021B0 .. UPWARDS ARROW WITH TIP LEFTWARDS

.. code-block:: cpp

   #ifndef CIRCULAR_BUFFER_HPP
   #define CIRCULAR_BUFFER_HPP
   
   #include <cstddef>
   #include <vector>
   
   #include "Tools/TypeDefinitions.h"
   
   namespace structure_utils {
   
   using std::vector;
   
   template <class T>
   class CircularBuffer {
   private:
     vector<T> q;
     u64 read_idx = 0, write_idx = 0, population = 0;
   
   public:
     explicit CircularBuffer(u64 size): q(size) {}
     CircularBuffer(u64 size, T default_value): q(size) {
       for (auto &x : q) { x = default_value; }
     }
     auto set(u64 idx, T value) { q[idx] = value; }
     auto get(u64 idx) -> T & { return q[idx]; }
   
     auto current_read() const -> const T & { return q[read_idx]; }
     auto current_write() -> T & { return q[write_idx]; }
   
     auto step_write() -> void {
       write_idx = (write_idx + 1) % q.size();
       --population;
     }
     auto step_read() -> void {
       read_idx = (read_idx + 1) % q.size();
       ++population;
     }
   
     [[nodiscard]] auto size() const -> u64 { return population; }
     [[nodiscard]] auto capacity() const -> u64 { return q.size(); }
     [[nodiscard]] auto empty() const -> bool { return population == 0; }
   };
   
   }  // namespace structure_utils
   
   #endif
